import { DEBUG, DEBUG_TEXTURES } from "~autogenerated";
import { overlayCtx } from "~renderer";
import { pushPixelsToTexture, SdfsTextureSize } from "~sdf/sdfRenderer";
import { forRangeN } from "~utils";


const svgCreateElement = (element: string) => {
    return document.createElementNS("http://www.w3.org/2000/svg", element);
};

const svgSetAttrib = (element: SVGElement, attrib: string, value: string) => {
    element.setAttribute(attrib, value);
};

// For now sizes are forzed to sdf renderer sizes

const seed = "1337";

/*
    <radialGradient id="fadeGrad">
      <stop offset="10%" stop-color="white" />
      <stop offset="95%" stop-color="black" />
    </radialGradient>

    <mask id="fade" maskContentUnits="objectBoundingBox">
      <rect width="1" height="1" fill="url(#fadeGrad)"/>
    </mask>

  <filter id="f" filterUnits="userSpaceOnUse"><feTurbulence type="fractalNoise" numOctaves="10" baseFrequency="0.01" stitchTiles="stitch" seed="1337"></feTurbulence></filter>

<rect width="100%" height="100%" fill="red" />

 <rect width="100%" height="100%"
    mask="url(#fade)"
    style="filter:url(#f);""
    fill=""
  />

*/


export const svgSetWidth = (el: SVGElement, w: string) => {
    svgSetAttrib(el, "width", w);
}

export const svgSetHeight = (el: SVGElement, h: string) => {
    svgSetAttrib(el, "height", h);
}

export const svgSetId = (el: SVGElement, id: string) => {
    svgSetAttrib(el, "id", id);
}

export const svgFullRect = (fill: string) => {
    const rect = svgCreateElement("rect");
    svgSetWidth(rect, "100%");
    svgSetHeight(rect, "100%");
    svgSetAttrib(rect, "fill", fill);
    return rect;
};

export const svgAppendChild = (a: SVGElement, b: SVGElement) => {
    a.appendChild(b);
};

const fbmParticle = () => {
    const size = SdfsTextureSize;

    const svg = svgCreateElement("svg");
    const sizeStr = `${size}`;
    svgSetWidth(svg, sizeStr);
    svgSetHeight(svg, sizeStr);

    const filter = svgCreateElement("filter");
    svgSetId(filter, "f");
    svgSetAttrib(filter, "filterUnits", "userSpaceOnUse");

    const turbulence = svgCreateElement("feTurbulence");

    svgSetAttrib(turbulence, "type", "fractalNoise");
    svgSetAttrib(turbulence, "numOctaves", "10");
    svgSetAttrib(turbulence, "baseFrequency", "0.01");
    svgSetAttrib(turbulence, "stitchTiles", "stitch");
    svgSetAttrib(turbulence, "seed", seed);
    svgSetAttrib(turbulence, "result", "t");

    svgAppendChild(filter, turbulence);

    // Desaturate turbu
    
    const desaturate = svgCreateElement("feColorMatrix");
    svgSetAttrib(desaturate,"type","saturate");
    svgSetAttrib(desaturate,"values","0")
    svgAppendChild(filter, desaturate);
    
    svgAppendChild(svg, filter);

    const radialGrad = svgCreateElement("radialGradient");
    svgSetId(radialGrad, "g");
    const addStop = (offset: string, color: string) => {
        const stop = svgCreateElement("stop");
        svgSetAttrib(stop, "offset", offset);
        svgSetAttrib(stop, "stop-color", color);
        svgAppendChild(radialGrad, stop);
    };

    addStop("10%", "white");
    addStop("95%", "black");

    svgAppendChild(svg, radialGrad);

    const mask = svgCreateElement("mask");
    svgSetId(mask, "m");

    const maskRect = svgFullRect("url(#g)");
    svgAppendChild(mask, maskRect);

    svgAppendChild(svg, mask);

    const finalRect = svgFullRect("");
    svgSetAttrib(finalRect, "style", "filter:url(#f)");
    svgSetAttrib(finalRect, "mask", "url(#m)")
    svgAppendChild(svg, finalRect);

    if (DEBUG && DEBUG_TEXTURES) {
        document.body.appendChild(svg);
    }

    return svg;
};

export let SvgTextureFbmParticle: number;

export const renderSvgToTexture = (w: number, h: number, svg: SVGElement) => {
    return new Promise<number>((resolve) => {
        const img = document.createElement("img");
        const svgSrc = (new XMLSerializer()).serializeToString(svg);

        img.onload = () => {
            const canvas = document.createElement("canvas");
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;
            ctx.drawImage(img, 0, 0);
            const data = ctx.getImageData(0, 0, w, h).data;
            for (let i = 0; i < data.length; i += 4) {
                const a = data[i + 3] / 0xFF;
                data[i] *= a;
                data[i + 1] *= a;
                data[i + 2] *= a;
            }
            resolve(pushPixelsToTexture(data));
        };
        img.src = `data:image/svg+xml;base64,${btoa(svgSrc)}`;
    });
};

export const createSvgTextures = async () => {
    let ts = 0;

    if (DEBUG) {
        ts = performance.now();
    }

    SvgTextureFbmParticle = await renderSvgToTexture(SdfsTextureSize, SdfsTextureSize, fbmParticle());

    if (DEBUG) {
        console.log(`createSvgTextures in ${performance.now() - ts} ms`);
    }
};