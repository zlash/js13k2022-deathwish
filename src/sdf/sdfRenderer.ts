import { gl, createProgram, createUBO, createTexture, setFramebuffer, getUniformLocation, WebGLShaderBundle, TextureArray, createTextureArray, pushTextureArrayLayer } from "../webgl";
import { screenVert, sdfFrag } from "../shaders/bundle";
import * as glEnum from "../webglEnums";
import { DEBUG, DEBUG_TEXTURES } from "../autogenerated";
import { getDirVec2, vec3, vec3Splay, vecMulK } from "../juvec";

import { SdfBuilder, pushBox, pushSymX, pushSymY, pushSymZ, pushSphere, pushEnd, createSdf, sdfCells, pushTranslation, popPosition, pushUnion, pushMaterial, popMaterial, pushSubtraction, pushTwistY, pushAlbedo, pushCone, pushRotationXZ, pushCylinder, pushRotationYZ, pushScale, box, cylinder, union, subtract, sphere, smoothUnion } from "./sdfBuilder";
import { random, randomRange, TwoPi } from "../aliasedFunctions";
import * as Palette from "../palette";

import * as Ids from "./sdfIds";
import { arrayRange, genArrayFromGrid, mix, promiseToNextFrame, waitAFrame } from "../utils";
import { camera, drawLoadingScreen, LoadingSdf, popCameraAngle, pushCameraAngle } from "../renderer";
import { state } from "../game";
import { buildSdfAssets } from "./sdfAssets";
import { createSvgTextures } from "~svgTextures";
import { MenuGear } from "./sdfAssetsIds";

let sdfProgram: WebGLShaderBundle;
let sdfBuffer: WebGLBuffer;
let sdfVao: WebGLVertexArrayObject;
let sdfUBOBuffer: WebGLBuffer;

export const renderSdfToUint8ClampedArray = (sdf: SdfBuilder, width: number, height: number) => {
    // Offscreen rendering init
    const offscreenTexture = createTexture(width, height, glEnum.RGBA, null);

    const framebuffer = gl.createFramebuffer() as WebGLFramebuffer;
    gl.bindFramebuffer(glEnum.FRAMEBUFFER, framebuffer);
    const attachmentPoint = glEnum.COLOR_ATTACHMENT0;
    gl.framebufferTexture2D(glEnum.FRAMEBUFFER, attachmentPoint, glEnum.TEXTURE_2D, offscreenTexture, 0);

    setFramebuffer(framebuffer, width, height);
    gl.clear(glEnum.COLOR_BUFFER_BIT | glEnum.DEPTH_BUFFER_BIT);

    gl.useProgram(sdfProgram.program);

    gl.bindBuffer(glEnum.UNIFORM_BUFFER, sdfUBOBuffer);
    gl.bufferSubData(glEnum.UNIFORM_BUFFER, 0, sdf.buf);

    gl.uniformMatrix4fv(sdfProgram.uniforms["_wm"], false, camera.viewProjection);

    gl.bindBuffer(glEnum.ARRAY_BUFFER, sdfBuffer);
    gl.bindVertexArray(sdfVao);
    gl.drawArrays(glEnum.TRIANGLE_STRIP, 0, 4);

    // Get buffer data and attach it to dom
    const pixels = new Uint8ClampedArray(width * height * 4);
    gl.readPixels(0, 0, width, height, glEnum.RGBA, glEnum.UNSIGNED_BYTE, pixels);

    if (DEBUG_TEXTURES) {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;
        const imgData = new ImageData(pixels, width, height);
        ctx.putImageData(imgData, 0, 0);
        const img = document.createElement("img");
        img.src = canvas.toDataURL();
        document.body.appendChild(img);
    }

    gl.deleteFramebuffer(framebuffer);
    gl.deleteTexture(offscreenTexture);

    return pixels;
};


export interface SdfRender {
    texture: number; // Right now we are using atlas 
    // Will need to do stuff to allow cropping and shit    
}

export let sdfsTexture: TextureArray;


export const pushPixelsToTexture = (pixels: Uint8ClampedArray) => {
    const id = sdfsTexture.curLayer;
    pushTextureArrayLayer(sdfsTexture, pixels);
    return id;
};

export const renderSdf = async (sdf: SdfBuilder) => {
    let render = {} as SdfRender;
    await promiseToNextFrame(() => {
        const pixels = renderSdfToUint8ClampedArray(sdf, sdfsTexture.w, sdfsTexture.h);
        // Here creates the "texture" for the current sdf
        render.texture = pushPixelsToTexture(pixels);

    });
    return render;
}

export const createSdfData = async () => {
    let ts = 0;

    // Reserve first texture for fire!
    pushPixelsToTexture(new Uint8ClampedArray(SdfsTextureSize * SdfsTextureSize * 4));

    console.log("Begin generating SDF data...");
    if (DEBUG) {
        ts = performance.now();
    }

    const sdfs = buildSdfAssets();

    for (let i = 0; i < sdfs.length; i++) {
        const frontFacing = i >= sdfs.length - 4;
        if (frontFacing) {
            pushCameraAngle(0, 0);
        }
        await sdfs[i]();
        if (frontFacing) {
            popCameraAngle();
        }
        const base = i == 0 ? 0 : 0.25;
        drawLoadingScreen(mix(LoadingSdf, 1, base + 0.75 * i / (sdfs.length - 1)));
        await waitAFrame();
    }

    gl.bindTexture(glEnum.TEXTURE_2D_ARRAY, sdfsTexture.tex);

    if (DEBUG) {
        console.log(`SDF data generated in ${performance.now() - ts} ms`);
    }
};

export const SdfsTextureSize = 256;

export const init = () => {
    sdfProgram = createProgram(screenVert, sdfFrag);
    getUniformLocation(sdfProgram, "_wm");

    sdfBuffer = gl.createBuffer() as WebGLBuffer;

    gl.bindBuffer(glEnum.ARRAY_BUFFER, sdfBuffer);

    gl.bufferData(glEnum.ARRAY_BUFFER, new Float32Array([
        -1, 1,
        -1, -1,
        1, 1,
        1, -1,
    ]), glEnum.STATIC_DRAW);

    sdfVao = gl.createVertexArray() as WebGLVertexArrayObject;

    gl.bindVertexArray(sdfVao);
    gl.vertexAttribPointer(0, 2, glEnum.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0);

    // UBO
    const sdfUBOIndex = gl.getUniformBlockIndex(sdfProgram.program, "Bytecode");
    gl.uniformBlockBinding(sdfProgram.program, sdfUBOIndex, 0);

    sdfUBOBuffer = createUBO(sdfCells * 4 * 4);
    gl.bindBufferBase(glEnum.UNIFORM_BUFFER, 0, sdfUBOBuffer);
    gl.bindBufferRange(glEnum.UNIFORM_BUFFER, 0, sdfUBOBuffer, 0, sdfCells * 4 * 4);


    sdfsTexture = createTextureArray(SdfsTextureSize, SdfsTextureSize, 256, glEnum.RGBA8);
};