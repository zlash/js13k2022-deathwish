import { DEBUG } from "./autogenerated";

import { sqrt, assert, sin, cos, atan2, acos, asin, floor, clamp } from "./aliasedFunctions";
import { mix } from "./utils";

/*
    All vectors have 4 components to avoid different functions for each size
*/

// TODO : FMA XD

export const vec2 = (x: number, y: number) => {
    return [x, y, 0, 0];
};

export const vec2Splay = (k: number) => {
    return [k, k, 0, 0];
};

export const vec2Copy = (v: Vec2) => {
    return [v[0], v[1], 0, 0];
}

export const vec3 = (x: number, y: number, z: number) => {
    return [x, y, z, 0];
};

export const vec3Splay = (k: number) => {
    return [k, k, k, 0];
};

export const vec4 = (x: number, y: number, z: number, w: number) => {
    return [x, y, z, w];
};

export const vec4Splay = (k: number) => {
    return [k, k, k, k];
};

export const vecReset = (a: number[]) => {
    a[0] = a[1] = a[2] = a[3] = 0;
};

export const vecClamp = (v: number[], a: number[], b: number[], r: number[]) => {
    r[0] = clamp(v[0], a[0], b[0]);
    r[1] = clamp(v[1], a[1], b[1]);
    r[2] = clamp(v[2], a[2], b[2]);
    r[3] = clamp(v[3], a[3], b[3]);
};

export const vecSet = (dst: number[], src: number[]) => {
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    return dst;
};

export const vecEq = (a: number[], b: number[]) => {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

export const vecFloor = (v: number[], r: number[]) => {
    r[0] = floor(v[0]);
    r[1] = floor(v[1]);
    r[2] = floor(v[2]);
    r[3] = floor(v[3]);
    return r;
};

export const vecAdd = (a: number[], b: number[], r: number[]) => {
    r[0] = a[0] + b[0];
    r[1] = a[1] + b[1];
    r[2] = a[2] + b[2];
    r[3] = a[3] + b[3];
    return r;
};

export const vecMul = (a: number[], b: number[], r: number[]) => {
    r[0] = a[0] * b[0];
    r[1] = a[1] * b[1];
    r[2] = a[2] * b[2];
    r[3] = a[3] * b[3];
    return r;
};

export const vecMulK = (a: number[], k: number, r: number[]) => {
    r[0] = a[0] * k;
    r[1] = a[1] * k;
    r[2] = a[2] * k;
    r[3] = a[3] * k;
    return r;
};

export const vecSub = (a: number[], b: number[], r: number[]) => {
    r[0] = a[0] - b[0];
    r[1] = a[1] - b[1];
    r[2] = a[2] - b[2];
    r[3] = a[3] - b[3];
    return r;
};

export const vecDot = (a: number[], b: number[]) => {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

export const vecLength = (a: number[]) => {
    return sqrt(vecDot(a, a));
};

export const vecNormalizeSafe = (a: number[], r: number[]) => {
    const l = vecLength(a);
    if (l === 0) {
        vecReset(r);
    } else {
        vecMulK(a, 1 / l, r);
    }
    return r;
};

export const vecMix = (a: number[], b: number[], k: number, r: number[]) => {
    r[0] = mix(a[0], b[0], k);
    r[1] = mix(a[1], b[1], k);
    r[2] = mix(a[2], b[2], k);
    r[3] = mix(a[3], b[3], k);
}

export const vec3Cross = (a: number[], b: number[], r: number[]) => {
    assert(a != r);
    r[0] = a[1] * b[2] - a[2] * b[1];
    r[1] = a[2] * b[0] - a[0] * b[2];
    r[2] = a[0] * b[1] - a[1] * b[0];
    return r;
};

export const vec2Rotate = (a: number[], deg: number, r: number[]) => {
    const c = cos(deg);
    const s = sin(deg);
    const r0 = c * a[0] - s * a[1];
    const r1 = s * a[0] + c * a[1];
    r[0] = r0;
    r[1] = r1;
    return r;
};

export const quatFromAxisAngle = (axis: number[], angle: number, r: number[]) => {
    const ha = angle / 2;
    r[0] = cos(ha);
    r[1] = axis[0] * sin(ha);
    r[2] = axis[1] * sin(ha);
    r[3] = axis[2] * sin(ha);
    return r;
};

// Dir must be normalized, No UP, dir cant be (0,1,0) or (0,-1,0)
export const quatFromDirection = (dir: number[], r: number[]) => {
    const yAngle = asin(dir[1]);
    const q1 = quatFromAxisAngle(xAxis, yAngle, vec4Splay(0));
    const zxAngle = -atan2(dir[0], dir[2]);
    const q2 = quatFromAxisAngle(yAxis, zxAngle, vec4Splay(0));
    return quatMul(q1, q2, vec4Splay(0));
};

export const quatMul = (a: number[], b: number[], r: number[]) => {
    assert(a != r);

    r[0] = a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3];
    r[1] = a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2];
    r[2] = a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1];
    r[3] = a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0];

    return r;
};

export const quatConjugate = (q: number[], r: number[]) => {
    r[0] = q[0];
    r[1] = -q[1];
    r[2] = -q[2];
    r[3] = -q[3];
    return r;
};

export const quatRotateVector = (q: number[], v: number[], r: number[]) => {
    const p = vec4(0, v[0], v[1], v[2]);
    const nq = quatMul(q, p, vec4Splay(0));
    const c = quatConjugate(q, vec4Splay(0));
    quatMul(nq, c, r);
    r[0] = r[1];
    r[1] = r[2];
    r[2] = r[3];
    r[3] = 0;
    return r;
};

export const angleBetweenVec2 = (a: number[], b: number[]) => {
    return atan2(b[1] * a[0] - b[0] * a[1], b[0] * a[0] + b[1] * a[1]);
};

export const getDirVec2 = (angle: number) => {
    return vec2(cos(angle), sin(angle));
};


export const mat4Vec4Mul = (mat: Mat4, v: Vec4, r: Vec4) => {
    r[0] = mat[0] * v[0] + mat[4] * v[1] + mat[8] * v[2] + mat[12] * v[3];
    r[1] = mat[1] * v[0] + mat[5] * v[1] + mat[9] * v[2] + mat[13] * v[3];
    r[2] = mat[2] * v[0] + mat[6] * v[1] + mat[10] * v[2] + mat[14] * v[3];
    r[3] = mat[3] * v[0] + mat[7] * v[1] + mat[11] * v[2] + mat[15] * v[3];
    return r;
};

export type Vec2 = ReturnType<typeof vec2>;
export type Vec3 = ReturnType<typeof vec3>;
export type Vec4 = ReturnType<typeof vec4>;
export type Mat4 = number[];

export const xAxis = vec3(1, 0, 0);
export const yAxis = vec3(0, 1, 0);
export const zAxis = vec3(0, 0, 1);
export const zeroVector = vec4Splay(0);